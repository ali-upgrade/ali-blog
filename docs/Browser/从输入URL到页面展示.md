# 从输入URL到页面展现
* URL输入
* DNS解析
* TCP连接(三次握手)连接复用
* 发送HTTP请求(请求的四部分)
* 服务器送`HTTP`响应
* 关闭`TCP`连接(四次挥手)
* 浏览器解析渲染页面

## URL输入
```
首先我们是在浏览器中输入URL，URL中文名叫统一资源定位符，统一资源定位符是对可以从互联网上得到的资源的位置和访问的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个的URL,它包含的信息指出文件的位置以及浏览器应该怎么处理它
```
当用户输入URL时浏览器进程的ui线程会捕捉输入内容，如果访问的是网址则ui线程会启动一个网络线程来请求DNS进行域名解析，如果不是网址而是一串关键词浏览就会使用默认配置的所有引擎查询

主要组成部分：`protocol(协议)://hostname(主机名)[:port](端口)/path(路径)/[;parameters](参数)`这里我们要主要的是浏览器遵循的同源策略，我们前端访问接口的时候通常会遇到跨域的问题，这里所有的域是协议，端口，域名的合集，同域就是所协议、域名和端口号均相同，任何一个不同都是跨域。

## DNS解析
DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如`www.google.com`，其实不是`google`网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的`IP`地址，但是`IP`地址并不方便记忆。用户更喜欢用方便记忆的网站去寻找互联网上的其他计算机，也就是上面提到的谷歌的网址。所以互联网设计这需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网站到`IP`地址的转换，这个过程就是`DNS解析`。实际上充当了一个翻译的角色，实现了网址到`IP`地址的转换。
### DNS查找顺序
浏览器缓存->操作系统缓存->本地host文件->路由器缓存->ISP DNS缓存->顶级DNS服务器/根DNS服务器。分析查找`www.google.com`的IP地址过程：.->.com->goole.com->www.google.com。这里的.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下,为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为：`.->.com->google.com->www.google.com`。
### DNS查询的两种方式：递归查询和迭代查询
1.递归查询

当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域服务器一级级向下查询。最后得到的查询结果返回局部DNS服务器，再由局部DNS服务器返回给客户端

2.迭代查询

当局部DNS服务器自己不能回答客户端的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己想其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。

### DNS负载均衡
当一个网站有足够多的用户时，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会挂。处理办法就是使用`DNS负载均衡技术`，它的原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每个每台机器的负载量，该机器离用户地理位置的距离等

### DNS缓存
计算机有域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存的IP，提高响应的速度。当然缓存是有有效时间的。

但是域名缓存机制也可能会带来麻烦。例如IP已变化了，仍然使用缓存中的IP来访问，将会访问失败。再如 同一个域名在内网和外网访问时所对应的IP是不同的，如在外网访问时通过外网IP映射到内网的IP。同一台电脑在外网环境下访问了此域名，再换到内网来访问此域名，在DNS缓存的作用下，也会去访问外网的IP，导致访问失败。根据情况，可以手动清除DNS缓存或者禁止DNS缓存机制。
在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。系统缓存主要存在/etc/hosts(Linux系统)中

## TCP三次握手

详细移步TCP三次握手与四次挥手，在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立第一次链，这是TCP协议完成的

## 发送HTTP请求
建立TCP连接之后，发起一个http请求。一个经典的`http request header`一般需要包括请求的方法，例如`GET,POST`等，不常用的还有`PUT`和`DELETE`,`OPTION`,`RACE`
完整的`HTTP`请求包括请求起始行，请求头部，请求主体三部分

|  分类  | GET  | POST |
|  ---- | ---- | ---- |
| 缓存 | 能被缓存 | 不能缓存   |
| 历史 | 参数保留在浏览器历史中 |  参数不会保存在浏览器历史中  |
| 安全性 | 安全性较差 | 相比GET更安全 |
| 可见性 | 数据在URL | 数据不在URL中 |

其实看看其他请求方法的名字就能大概知道在什么时候用什么方法,这就很好的体现了语义化
先下结论，GET 和 POST 方法没有实质区别，只是报文格式不同。
GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。
报文格式上，不带参数时，最大区别就是第一行方法名不同.不带参数时他们的区别就仅仅是报文的前几个字符不同而已
POST 方法请求报文第一行是这样的 POST /uri HTTP/1.1 \r\n
GET 方法请求报文第一行是这样的 GET /uri HTTP/1.1 \r\n
带参数时报文的区别:
在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中
举个例子，如果参数是 name=qiming.c, age=22。

 ### 总结
 * GET - 从指定的资源请求数据。是无副作用的，是幂等的，且可缓存
 * POST - 用于向指定的资源提交要被处理的数据，有副作用，非幂等，不可缓存
 * 参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里
 * 安全。POST 相对 GET 安全（只是相对安全）
 * GET的URL会有长度上的限制， POST可以传输很多数据,GET 的参数（url查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（也是有4~10Mb 限制）
 * GET 用来读数据，POST 用来写数据，POST 不幂等（幂等的意思就是不管发多少次请求，结果都一样。）

### HTTPS与HTTP的区别
* https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
* http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 服务器返回一个HTTP响应
